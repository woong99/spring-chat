worker_processes  2;

# nginx-lua 로깅 설정
error_log /var/log/nginx-lua.log debug;

events {
    worker_connections  10000;
    # worker_processes and worker_connections allows you to calculate maxclients value:
    # max_clients = worker_processes * worker_connections
}

http {
  resolver 127.0.0.11 valid=10s ipv6=off;

  init_worker_by_lua_block {
      local http = require "resty.http"
      local xml2lua = require "xml2lua"
      local handler = require "xmlhandler.tree"

      -- XML 파싱 함수
      local function parse_xml(xml)
          -- 빈 값이나 잘못된 값이 들어오면 리턴
          if not xml or xml == "" then
              ngx.log(ngx.ERR, "Empty or nil XML data received")
              return nil
          end

          -- XML 파서를 초기화
          local handler = handler:new()
          local parser = xml2lua.parser(handler)

          -- XML 파싱
          local success, err = pcall(function()
              parser:parse(xml)
          end)

          if not success then
              ngx.log(ngx.ERR, "XML Parsing Error: ", err)
              return nil
          end

          return handler.root
      end

      -- IP 주소 추출 함수
      local function extract_ip_addresses(xml)
          local parsed_xml = parse_xml(xml)
          if not parsed_xml then
              ngx.log(ngx.ERR, "Failed to parse XML")
              return nil
          end

          if #parsed_xml.applications.application.instance == 0 then
              ngx.log(ngx.INFO, "No instances found in the XML")
              return
          end

          -- applications -> application -> instance -> ipAddr
          local ip_addresses = {}

          for _, instance in ipairs(parsed_xml.applications.application.instance) do
            ip_addresses[instance.ipAddr .. ":8080"] = true
          end

          -- 공유 메모리에 IP가 없는 경우 추가
          for ip, _ in pairs(ip_addresses) do
              -- IP가 공유 메모리에 존재하는지 확인
              local found = ngx.shared.ws_servers:get(ip)

              if not found then
                  -- 존재하지 않으면 공유 메모리에 추가
                  ngx.shared.ws_servers:set(ip, true)
              end
          end

          -- Health Check 후 존재하지 않는 서버 목록 동기화
          local servers = ngx.shared.ws_servers:get_keys()
          for _, key in ipairs(servers) do
            if ip_addresses[key] then
                ngx.log(ngx.INFO, "IP exists in the table: " .. key)
            else
              ngx.shared.ws_servers:delete(key)
              ngx.log(ngx.INFO, "IP does not exist in the table: " .. key)
            end
          end

          for _, key in ipairs(servers) do
              ngx.log(ngx.INFO, "Key: " .. key)
          end
      end

      -- 헬스체크를 수행하는 함수
      local function health_check()
          local httpc = http.new()

          local res, err = httpc:request_uri("http://eureka-server:8761/eureka/apps", {
              method = "GET"
          })

          if not res then
              ngx.log(ngx.ERR, "Failed to request: ", err)
              return
          end

          -- Response에서 ipAddr 값 추출
          extract_ip_addresses(res.body)
      end

      -- 주기적인 작업을 설정
      local function schedule_health_check()
          ngx.timer.at(0, health_check)
          -- 5초마다 헬스체크를 주기적으로 실행
          ngx.timer.every(5, health_check)
      end

      -- 헬스체크 스케줄링
      schedule_health_check()
  }

  upstream spring-10k-chat-api {
	  server spring-10k-chat-api:8080;
  }

  upstream spring-10k-chat-sse {
    server spring-10k-chat-sse:8080;
  }

  client_max_body_size 10M;

  map $http_origin $cors_origin {
    default "";
    "http://localhost:3000" $http_origin;
    "http://dev.dulian.kr" $http_origin;
  }

  lua_shared_dict ws_servers 1m;

  server {
    listen       80;
    server_name  localhost;

    # WebSocket 서버 등록
    location /ws-up {
      content_by_lua_block {
        ngx.log(ngx.INFO, "WS Up Server IP : ",  ngx.var.arg_ip)
        ngx.shared.ws_servers:set(ngx.var.arg_ip .. ":8080", 1)
      }
    }

    # WebSocket 서버 제거
    location /ws-down {
      content_by_lua_block {
        ngx.log(ngx.INFO, "WS Down Server IP : ",  ngx.var.arg_ip)
        ngx.shared.ws_servers:delete(ngx.var.arg_ip .. ":8080")
      }
    }

    # API 서버
    location / {
      proxy_pass http://spring-10k-chat-api;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      if ($request_method = OPTIONS) {
        add_header 'Access-Control-Allow-Origin' $cors_origin;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE';
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, X-Requested-With';
        add_header 'Access-Control-Allow-Credentials' 'true';
        return 204;
      }
    }

    # WebSocket 서버
    set $target_ws '';
	  location /ws-stomp {
	    content_by_lua_block {
        local servers = ngx.shared.ws_servers:get_keys()
        ngx.log(ngx.INFO, "Available WS Servers : ", #servers)

        if #servers > 0 then
          math.randomseed(os.time())
          local random_index = math.random(#servers)
          local selected_server = servers[random_index]

          ngx.var.target_ws = selected_server
          ngx.log(ngx.INFO, "Selected WS Server : ", selected_server)
        else
            ngx.log(ngx.ERR, "No available websocket servers.")
            return
        end

        ngx.exec("@ws-stomp-upstream")
      }
	  }

	  location @ws-stomp-upstream {
 	    proxy_pass http://$target_ws;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "Upgrade";
      proxy_set_header Host $host;
    }

    # SSE 서버
	  location /api/v1/chat-room/notification/subscribe {
	    proxy_pass http://spring-10k-chat-sse;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      # SSE 설정
	    proxy_read_timeout 3600s;
	    proxy_buffering off;
    }
  }

  # DataDog 설정
  server {
    listen 81;
    server_name localhost;

    access_log off;
  #   allow 127.0.0.1;
    allow all;
    deny all;

    location /nginx_status {
      # Choose your status module

      # freely available with open source NGINX
      stub_status;

      # for open source NGINX < version 1.7.5
      # stub_status on;

      # available only with NGINX Plus
      # status;

      # ensures the version information can be retrieved
      server_tokens on;
    }
  }
}
